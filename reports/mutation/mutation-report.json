{"files":{"server/crypto.ts":{"language":"typescript","mutants":[{"id":"3","mutatorName":"StringLiteral","replacement":"\"\"","status":"NoCoverage","static":false,"coveredBy":[],"location":{"end":{"column":84,"line":4},"start":{"column":50,"line":4}}},{"id":"5","mutatorName":"BlockStatement","replacement":"{}","statusReason":"The \"key\" argument must be of type string or an instance of ArrayBuffer, Buffer, TypedArray, DataView, KeyObject, or CryptoKey. Received undefined","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19"],"location":{"end":{"column":2,"line":17},"start":{"column":42,"line":15}}},{"id":"6","mutatorName":"BlockStatement","replacement":"{}","statusReason":"Cannot read properties of undefined (reading 'slice')","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19"],"location":{"end":{"column":2,"line":37},"start":{"column":47,"line":23}}},{"id":"7","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","static":false,"testsCompleted":20,"coveredBy":["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19"],"location":{"end":{"column":45,"line":30},"start":{"column":39,"line":30}}},{"id":"8","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"The argument 'encoding' is invalid for data of length 19. Received 'hex'","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19"],"location":{"end":{"column":52,"line":30},"start":{"column":47,"line":30}}},{"id":"9","mutatorName":"AssignmentOperator","replacement":"encrypted -= cipher.final(\"hex\")","statusReason":"The argument 'encoding' is invalid for data of length 3. Received 'hex'","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19"],"location":{"end":{"column":35,"line":31},"start":{"column":3,"line":31}}},{"id":"10","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","static":false,"testsCompleted":20,"coveredBy":["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19"],"location":{"end":{"column":34,"line":31},"start":{"column":29,"line":31}}},{"id":"11","mutatorName":"ArithmeticOperator","replacement":"salt.toString(\"hex\") + iv.toString(\"hex\") + authTag.toString(\"hex\") - encrypted","statusReason":"encryptedText.slice is not a function","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19"],"location":{"end":{"column":89,"line":36},"start":{"column":10,"line":36}}},{"id":"12","mutatorName":"ArithmeticOperator","replacement":"salt.toString(\"hex\") + iv.toString(\"hex\") - authTag.toString(\"hex\")","statusReason":"Invalid authentication tag length: 0","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19"],"location":{"end":{"column":77,"line":36},"start":{"column":10,"line":36}}},{"id":"13","mutatorName":"ArithmeticOperator","replacement":"salt.toString(\"hex\") - iv.toString(\"hex\")","statusReason":"Invalid authentication tag length: 6","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19"],"location":{"end":{"column":51,"line":36},"start":{"column":10,"line":36}}},{"id":"14","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"Unknown encoding: ","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19"],"location":{"end":{"column":29,"line":36},"start":{"column":24,"line":36}}},{"id":"15","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"Unknown encoding: ","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19"],"location":{"end":{"column":50,"line":36},"start":{"column":45,"line":36}}},{"id":"16","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"Unknown encoding: ","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19"],"location":{"end":{"column":76,"line":36},"start":{"column":71,"line":36}}},{"id":"17","mutatorName":"BlockStatement","replacement":"{}","statusReason":"expected undefined to be 'sk-test-api-key-12345' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":2,"line":63},"start":{"column":56,"line":43}}},{"id":"18","mutatorName":"MethodExpression","replacement":"encryptedText","statusReason":"Unsupported state or unable to authenticate data","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":67,"line":45},"start":{"column":28,"line":45}}},{"id":"19","mutatorName":"ArithmeticOperator","replacement":"SALT_LENGTH / 2","statusReason":"Unsupported state or unable to authenticate data","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":66,"line":45},"start":{"column":51,"line":45}}},{"id":"20","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"Unsupported state or unable to authenticate data","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":74,"line":45},"start":{"column":69,"line":45}}},{"id":"21","mutatorName":"MethodExpression","replacement":"encryptedText","statusReason":"Unsupported state or unable to authenticate data","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":95,"line":46},"start":{"column":26,"line":46}}},{"id":"22","mutatorName":"ArithmeticOperator","replacement":"SALT_LENGTH / 2","statusReason":"Unsupported state or unable to authenticate data","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":61,"line":46},"start":{"column":46,"line":46}}},{"id":"23","mutatorName":"ArithmeticOperator","replacement":"SALT_LENGTH * 2 - IV_LENGTH * 2","statusReason":"Invalid initialization vector","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":94,"line":46},"start":{"column":63,"line":46}}},{"id":"24","mutatorName":"ArithmeticOperator","replacement":"SALT_LENGTH / 2","statusReason":"Unsupported state or unable to authenticate data","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":78,"line":46},"start":{"column":63,"line":46}}},{"id":"25","mutatorName":"ArithmeticOperator","replacement":"IV_LENGTH / 2","statusReason":"Unsupported state or unable to authenticate data","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":94,"line":46},"start":{"column":81,"line":46}}},{"id":"26","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"Unsupported state or unable to authenticate data","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":102,"line":46},"start":{"column":97,"line":46}}},{"id":"27","mutatorName":"MethodExpression","replacement":"encryptedText","statusReason":"Invalid authentication tag length: 69","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":112,"line":48},"start":{"column":5,"line":48}}},{"id":"28","mutatorName":"ArithmeticOperator","replacement":"SALT_LENGTH * 2 - IV_LENGTH * 2","statusReason":"Invalid authentication tag length: 48","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":56,"line":48},"start":{"column":25,"line":48}}},{"id":"29","mutatorName":"ArithmeticOperator","replacement":"SALT_LENGTH / 2","statusReason":"Invalid authentication tag length: 28","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":40,"line":48},"start":{"column":25,"line":48}}},{"id":"30","mutatorName":"ArithmeticOperator","replacement":"IV_LENGTH / 2","statusReason":"Invalid authentication tag length: 28","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":56,"line":48},"start":{"column":43,"line":48}}},{"id":"31","mutatorName":"ArithmeticOperator","replacement":"SALT_LENGTH * 2 + IV_LENGTH * 2 - AUTH_TAG_LENGTH * 2","statusReason":"Invalid authentication tag length: 0","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":111,"line":48},"start":{"column":58,"line":48}}},{"id":"32","mutatorName":"ArithmeticOperator","replacement":"SALT_LENGTH * 2 - IV_LENGTH * 2","statusReason":"Invalid authentication tag length: 0","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":89,"line":48},"start":{"column":58,"line":48}}},{"id":"33","mutatorName":"ArithmeticOperator","replacement":"SALT_LENGTH / 2","statusReason":"expected [Function] to throw an error","status":"Killed","static":false,"testsCompleted":13,"killedBy":["17"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":73,"line":48},"start":{"column":58,"line":48}}},{"id":"34","mutatorName":"ArithmeticOperator","replacement":"IV_LENGTH / 2","statusReason":"expected [Function] to throw an error","status":"Killed","static":false,"testsCompleted":13,"killedBy":["17"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":89,"line":48},"start":{"column":76,"line":48}}},{"id":"35","mutatorName":"ArithmeticOperator","replacement":"AUTH_TAG_LENGTH / 2","statusReason":"expected [Function] to throw an error","status":"Killed","static":false,"testsCompleted":13,"killedBy":["17"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":111,"line":48},"start":{"column":92,"line":48}}},{"id":"36","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"Invalid authentication tag length: 32","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":10,"line":49},"start":{"column":5,"line":49}}},{"id":"37","mutatorName":"MethodExpression","replacement":"encryptedText","statusReason":"Unsupported state or unable to authenticate data","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":95,"line":51},"start":{"column":21,"line":51}}},{"id":"38","mutatorName":"ArithmeticOperator","replacement":"SALT_LENGTH * 2 + IV_LENGTH * 2 - AUTH_TAG_LENGTH * 2","statusReason":"Unsupported state or unable to authenticate data","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":94,"line":51},"start":{"column":41,"line":51}}},{"id":"39","mutatorName":"ArithmeticOperator","replacement":"SALT_LENGTH * 2 - IV_LENGTH * 2","statusReason":"Unsupported state or unable to authenticate data","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":72,"line":51},"start":{"column":41,"line":51}}},{"id":"40","mutatorName":"ArithmeticOperator","replacement":"SALT_LENGTH / 2","statusReason":"Unsupported state or unable to authenticate data","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":56,"line":51},"start":{"column":41,"line":51}}},{"id":"41","mutatorName":"ArithmeticOperator","replacement":"IV_LENGTH / 2","statusReason":"Unsupported state or unable to authenticate data","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":72,"line":51},"start":{"column":59,"line":51}}},{"id":"42","mutatorName":"ArithmeticOperator","replacement":"AUTH_TAG_LENGTH / 2","statusReason":"Unsupported state or unable to authenticate data","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":94,"line":51},"start":{"column":75,"line":51}}},{"id":"43","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"Unsupported state or unable to authenticate data","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":51,"line":59},"start":{"column":46,"line":59}}},{"id":"44","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","static":false,"testsCompleted":15,"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":59,"line":59},"start":{"column":53,"line":59}}},{"id":"45","mutatorName":"AssignmentOperator","replacement":"decrypted -= decipher.final(\"utf8\")","statusReason":"expected NaN to be 'sk-test-api-key-12345' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["0"],"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":38,"line":60},"start":{"column":3,"line":60}}},{"id":"46","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","static":false,"testsCompleted":15,"coveredBy":["0","1","3","4","5","7","9","10","13","14","15","16","17","18","19"],"location":{"end":{"column":37,"line":60},"start":{"column":31,"line":60}}},{"id":"47","mutatorName":"BlockStatement","replacement":"{}","statusReason":"expected undefined to be '2345' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["20"],"coveredBy":["20","21","22"],"location":{"end":{"column":2,"line":71},"start":{"column":52,"line":68}}},{"id":"48","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"expected '****' to be '2345' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["20"],"coveredBy":["20","21","22"],"location":{"end":{"column":24,"line":69},"start":{"column":7,"line":69}}},{"id":"49","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"expected 'abc' to be '****' // Object.is equality","status":"Killed","static":false,"testsCompleted":2,"killedBy":["21"],"coveredBy":["20","21","22"],"location":{"end":{"column":24,"line":69},"start":{"column":7,"line":69}}},{"id":"50","mutatorName":"EqualityOperator","replacement":"apiKey.length <= 4","statusReason":"expected '****' to be 'abcd' // Object.is equality","status":"Killed","static":false,"testsCompleted":3,"killedBy":["22"],"coveredBy":["20","21","22"],"location":{"end":{"column":24,"line":69},"start":{"column":7,"line":69}}},{"id":"51","mutatorName":"EqualityOperator","replacement":"apiKey.length >= 4","statusReason":"expected '****' to be '2345' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["20"],"coveredBy":["20","21","22"],"location":{"end":{"column":24,"line":69},"start":{"column":7,"line":69}}},{"id":"52","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"expected '' to be '****' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["21"],"coveredBy":["21"],"location":{"end":{"column":39,"line":69},"start":{"column":33,"line":69}}},{"id":"53","mutatorName":"MethodExpression","replacement":"apiKey","statusReason":"expected 'sk-test-api-key-12345' to be '2345' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["20"],"coveredBy":["20","22"],"location":{"end":{"column":26,"line":70},"start":{"column":10,"line":70}}},{"id":"54","mutatorName":"UnaryOperator","replacement":"+4","statusReason":"expected 'est-api-key-12345' to be '2345' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["20"],"coveredBy":["20","22"],"location":{"end":{"column":25,"line":70},"start":{"column":23,"line":70}}},{"id":"55","mutatorName":"BlockStatement","replacement":"{}","statusReason":"expected undefined to be 'sk-t...2345' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["23"],"coveredBy":["23","24","25"],"location":{"end":{"column":2,"line":79},"start":{"column":52,"line":76}}},{"id":"56","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"expected '****' to be 'sk-t...2345' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["23"],"coveredBy":["23","24","25"],"location":{"end":{"column":25,"line":77},"start":{"column":7,"line":77}}},{"id":"57","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"expected '1234...5678' to be '****' // Object.is equality","status":"Killed","static":false,"testsCompleted":2,"killedBy":["24"],"coveredBy":["23","24","25"],"location":{"end":{"column":25,"line":77},"start":{"column":7,"line":77}}},{"id":"58","mutatorName":"EqualityOperator","replacement":"apiKey.length < 8","statusReason":"expected '1234...5678' to be '****' // Object.is equality","status":"Killed","static":false,"testsCompleted":2,"killedBy":["24"],"coveredBy":["23","24","25"],"location":{"end":{"column":25,"line":77},"start":{"column":7,"line":77}}},{"id":"59","mutatorName":"EqualityOperator","replacement":"apiKey.length > 8","statusReason":"expected '****' to be 'sk-t...2345' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["23"],"coveredBy":["23","24","25"],"location":{"end":{"column":25,"line":77},"start":{"column":7,"line":77}}},{"id":"60","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"expected '' to be '****' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["24"],"coveredBy":["24"],"location":{"end":{"column":40,"line":77},"start":{"column":34,"line":77}}},{"id":"61","mutatorName":"MethodExpression","replacement":"apiKey","statusReason":"expected 'sk-test-api-key-12345...2345' to be 'sk-t...2345' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["23"],"coveredBy":["23","25"],"location":{"end":{"column":28,"line":78},"start":{"column":10,"line":78}}},{"id":"62","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"expected 'sk-t2345' to be 'sk-t...2345' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["23"],"coveredBy":["23","25"],"location":{"end":{"column":36,"line":78},"start":{"column":31,"line":78}}},{"id":"63","mutatorName":"MethodExpression","replacement":"apiKey","statusReason":"expected 'sk-t...sk-test-api-key-12345' to be 'sk-t...2345' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["23"],"coveredBy":["23","25"],"location":{"end":{"column":55,"line":78},"start":{"column":39,"line":78}}},{"id":"64","mutatorName":"UnaryOperator","replacement":"+4","statusReason":"expected 'sk-t...est-api-key-12345' to be 'sk-t...2345' // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["23"],"coveredBy":["23","25"],"location":{"end":{"column":54,"line":78},"start":{"column":52,"line":78}}},{"id":"0","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"The \"password\" argument must be of type string or an instance of ArrayBuffer, Buffer, TypedArray, or DataView. Received type boolean (true)","status":"Killed","static":true,"testsCompleted":1,"killedBy":["0"],"coveredBy":[],"location":{"end":{"column":84,"line":4},"start":{"column":24,"line":4}}},{"id":"1","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"The \"password\" argument must be of type string or an instance of ArrayBuffer, Buffer, TypedArray, or DataView. Received type boolean (false)","status":"Killed","static":true,"testsCompleted":1,"killedBy":["0"],"coveredBy":[],"location":{"end":{"column":84,"line":4},"start":{"column":24,"line":4}}},{"id":"2","mutatorName":"LogicalOperator","replacement":"process.env.JWT_SECRET && \"default-key-change-in-production\"","status":"Survived","static":true,"testsCompleted":70,"coveredBy":[],"location":{"end":{"column":84,"line":4},"start":{"column":24,"line":4}}},{"id":"4","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"Unknown cipher","status":"Killed","static":true,"testsCompleted":1,"killedBy":["0"],"coveredBy":[],"location":{"end":{"column":32,"line":6},"start":{"column":19,"line":6}}}],"source":"import crypto from \"crypto\";\n\n// Use JWT_SECRET as the base for encryption key\nconst ENCRYPTION_KEY = process.env.JWT_SECRET || \"default-key-change-in-production\";\n\nconst ALGORITHM = \"aes-256-gcm\";\nconst SALT_LENGTH = 16; // Random salt per encryption\nconst IV_LENGTH = 16;\nconst AUTH_TAG_LENGTH = 16;\n\n/**\n * Derive a 32-byte key from the secret using a random salt\n * SECURITY: Using per-encryption random salt prevents rainbow table attacks\n */\nfunction deriveKey(salt: Buffer): Buffer {\n  return crypto.scryptSync(ENCRYPTION_KEY, salt, 32);\n}\n\n/**\n * Encrypt a string (API key) using AES-256-GCM with per-encryption random salt\n * Format: salt (16 bytes) + iv (16 bytes) + authTag (16 bytes) + encrypted data\n */\nexport function encrypt(text: string): string {\n  // Generate random salt for each encryption\n  const salt = crypto.randomBytes(SALT_LENGTH);\n  const key = deriveKey(salt);\n  const iv = crypto.randomBytes(IV_LENGTH);\n  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);\n  \n  let encrypted = cipher.update(text, \"utf8\", \"hex\");\n  encrypted += cipher.final(\"hex\");\n  \n  const authTag = cipher.getAuthTag();\n  \n  // Combine salt + IV + authTag + encrypted data\n  return salt.toString(\"hex\") + iv.toString(\"hex\") + authTag.toString(\"hex\") + encrypted;\n}\n\n/**\n * Decrypt an encrypted string back to the original API key\n * Extracts the salt used during encryption to derive the same key\n */\nexport function decrypt(encryptedText: string): string {\n  // Extract salt, IV, authTag, and encrypted data\n  const salt = Buffer.from(encryptedText.slice(0, SALT_LENGTH * 2), \"hex\");\n  const iv = Buffer.from(encryptedText.slice(SALT_LENGTH * 2, SALT_LENGTH * 2 + IV_LENGTH * 2), \"hex\");\n  const authTag = Buffer.from(\n    encryptedText.slice(SALT_LENGTH * 2 + IV_LENGTH * 2, SALT_LENGTH * 2 + IV_LENGTH * 2 + AUTH_TAG_LENGTH * 2), \n    \"hex\"\n  );\n  const encrypted = encryptedText.slice(SALT_LENGTH * 2 + IV_LENGTH * 2 + AUTH_TAG_LENGTH * 2);\n  \n  // Derive the same key using the stored salt\n  const key = deriveKey(salt);\n  \n  const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n  decipher.setAuthTag(authTag);\n  \n  let decrypted = decipher.update(encrypted, \"hex\", \"utf8\");\n  decrypted += decipher.final(\"utf8\");\n  \n  return decrypted;\n}\n\n/**\n * Get the last 4 characters of an API key for display hint\n */\nexport function getKeyHint(apiKey: string): string {\n  if (apiKey.length < 4) return \"****\";\n  return apiKey.slice(-4);\n}\n\n/**\n * Mask an API key for display (show first 4 and last 4 chars)\n */\nexport function maskApiKey(apiKey: string): string {\n  if (apiKey.length <= 8) return \"****\";\n  return apiKey.slice(0, 4) + \"...\" + apiKey.slice(-4);\n}\n"}},"schemaVersion":"1.0","thresholds":{"high":80,"low":60,"break":40},"testFiles":{"server/crypto.test.ts":{"tests":[{"id":"0","name":"Crypto Module encrypt/decrypt should encrypt and decrypt a string correctly"},{"id":"1","name":"Crypto Module encrypt/decrypt should produce different ciphertexts for same plaintext (random salt)"},{"id":"2","name":"Crypto Module encrypt/decrypt should include salt in the encrypted output format"},{"id":"3","name":"Crypto Module encrypt/decrypt should handle empty strings"},{"id":"4","name":"Crypto Module encrypt/decrypt should handle long API keys"},{"id":"5","name":"Crypto Module encrypt/decrypt should handle special characters in API keys"},{"id":"6","name":"Crypto Module encrypt/decrypt should produce valid hex encoding in encrypted output"},{"id":"7","name":"Crypto Module encrypt/decrypt should use utf8 encoding for input and output"},{"id":"8","name":"Crypto Module encrypt/decrypt should correctly parse hex-encoded components during decryption"},{"id":"9","name":"Crypto Module encrypt/decrypt should fail decryption with tampered ciphertext"},{"id":"10","name":"Crypto Module encrypt/decrypt should fail decryption with tampered auth tag"},{"id":"11","name":"Crypto Module encrypt/decrypt should produce different encrypted lengths for different input lengths"},{"id":"12","name":"Crypto Module encrypt/decrypt should produce hex output that differs from base64 encoding"},{"id":"13","name":"Crypto Module encrypt/decrypt should correctly decode utf8 characters after decryption"},{"id":"14","name":"Crypto Module encrypt/decrypt should fail with incorrect slice boundaries for auth tag extraction"},{"id":"15","name":"Crypto Module encrypt/decrypt should fail decryption with wrong salt boundary"},{"id":"16","name":"Crypto Module encrypt/decrypt should fail decryption with wrong IV boundary"},{"id":"17","name":"Crypto Module encrypt/decrypt should fail decryption with wrong authTag boundary"},{"id":"18","name":"Crypto Module encrypt/decrypt should handle the default encryption key fallback"},{"id":"19","name":"Crypto Module encrypt/decrypt should produce consistent results with the same key"},{"id":"20","name":"Crypto Module getKeyHint should return last 4 characters of API key"},{"id":"21","name":"Crypto Module getKeyHint should return **** for keys shorter than 4 characters"},{"id":"22","name":"Crypto Module getKeyHint should return last 4 chars for exactly 4 character key"},{"id":"23","name":"Crypto Module maskApiKey should mask middle of API key"},{"id":"24","name":"Crypto Module maskApiKey should return **** for keys 8 characters or shorter"},{"id":"25","name":"Crypto Module maskApiKey should show first 4 and last 4 for longer keys"}],"source":"import { describe, it, expect } from \"vitest\";\nimport { encrypt, decrypt, getKeyHint, maskApiKey } from \"./crypto\";\n\ndescribe(\"Crypto Module\", () => {\n  describe(\"encrypt/decrypt\", () => {\n    it(\"should encrypt and decrypt a string correctly\", () => {\n      const originalText = \"sk-test-api-key-12345\";\n      const encrypted = encrypt(originalText);\n      const decrypted = decrypt(encrypted);\n      \n      expect(decrypted).toBe(originalText);\n    });\n\n    it(\"should produce different ciphertexts for same plaintext (random salt)\", () => {\n      const originalText = \"sk-test-api-key-12345\";\n      const encrypted1 = encrypt(originalText);\n      const encrypted2 = encrypt(originalText);\n      \n      // Due to random salt and IV, same plaintext should produce different ciphertexts\n      expect(encrypted1).not.toBe(encrypted2);\n      \n      // But both should decrypt to the same original text\n      expect(decrypt(encrypted1)).toBe(originalText);\n      expect(decrypt(encrypted2)).toBe(originalText);\n    });\n\n    it(\"should include salt in the encrypted output format\", () => {\n      const originalText = \"test-key\";\n      const encrypted = encrypt(originalText);\n      \n      // Format: salt (32 hex) + iv (32 hex) + authTag (32 hex) + encrypted data\n      // Minimum length should be 96 hex chars (48 bytes) + encrypted data\n      expect(encrypted.length).toBeGreaterThan(96);\n    });\n\n    it(\"should handle empty strings\", () => {\n      const originalText = \"\";\n      const encrypted = encrypt(originalText);\n      const decrypted = decrypt(encrypted);\n      \n      expect(decrypted).toBe(originalText);\n    });\n\n    it(\"should handle long API keys\", () => {\n      const originalText = \"sk-\" + \"a\".repeat(100);\n      const encrypted = encrypt(originalText);\n      const decrypted = decrypt(encrypted);\n      \n      expect(decrypted).toBe(originalText);\n    });\n\n    it(\"should handle special characters in API keys\", () => {\n      const originalText = \"sk-test_key-with/special+chars=123\";\n      const encrypted = encrypt(originalText);\n      const decrypted = decrypt(encrypted);\n      \n      expect(decrypted).toBe(originalText);\n    });\n\n    it(\"should produce valid hex encoding in encrypted output\", () => {\n      const originalText = \"test-encoding-verification\";\n      const encrypted = encrypt(originalText);\n      \n      // Verify the output is valid hex (only contains 0-9, a-f)\n      expect(encrypted).toMatch(/^[0-9a-f]+$/i);\n      \n      // Verify the encrypted data portion is also valid hex\n      const encryptedDataStart = 32 + 32 + 32; // salt + iv + authTag in hex\n      const encryptedData = encrypted.slice(encryptedDataStart);\n      expect(encryptedData).toMatch(/^[0-9a-f]+$/i);\n    });\n\n    it(\"should use utf8 encoding for input and output\", () => {\n      // Test with unicode characters to verify utf8 encoding\n      const originalText = \"APIå¯†é’¥ãƒ†ã‚¹ãƒˆðŸ”‘\";\n      const encrypted = encrypt(originalText);\n      const decrypted = decrypt(encrypted);\n      \n      expect(decrypted).toBe(originalText);\n      // Verify the decrypted text has the same byte length when encoded as utf8\n      expect(Buffer.from(decrypted, \"utf8\").length).toBe(Buffer.from(originalText, \"utf8\").length);\n    });\n\n    it(\"should correctly parse hex-encoded components during decryption\", () => {\n      const originalText = \"verify-hex-parsing\";\n      const encrypted = encrypt(originalText);\n      \n      // Verify structure: salt (32 hex) + iv (32 hex) + authTag (32 hex) + data\n      const saltHex = encrypted.slice(0, 32);\n      const ivHex = encrypted.slice(32, 64);\n      const authTagHex = encrypted.slice(64, 96);\n      \n      // Each component should be valid hex and correct length\n      expect(saltHex.length).toBe(32);\n      expect(ivHex.length).toBe(32);\n      expect(authTagHex.length).toBe(32);\n      \n      // Verify they can be parsed as hex buffers\n      expect(Buffer.from(saltHex, \"hex\").length).toBe(16);\n      expect(Buffer.from(ivHex, \"hex\").length).toBe(16);\n      expect(Buffer.from(authTagHex, \"hex\").length).toBe(16);\n    });\n\n    it(\"should fail decryption with tampered ciphertext\", () => {\n      const originalText = \"tamper-test\";\n      const encrypted = encrypt(originalText);\n      \n      // Tamper with the encrypted data portion (after salt+iv+authTag)\n      const tamperedEncrypted = encrypted.slice(0, 96) + \"ff\" + encrypted.slice(98);\n      \n      expect(() => decrypt(tamperedEncrypted)).toThrow();\n    });\n\n    it(\"should fail decryption with tampered auth tag\", () => {\n      const originalText = \"auth-tag-test\";\n      const encrypted = encrypt(originalText);\n      \n      // Tamper with the auth tag (bytes 64-96)\n      const tamperedAuthTag = encrypted.slice(0, 64) + \"00\".repeat(16) + encrypted.slice(96);\n      \n      expect(() => decrypt(tamperedAuthTag)).toThrow();\n    });\n\n    it(\"should produce different encrypted lengths for different input lengths\", () => {\n      const short = encrypt(\"a\");\n      const medium = encrypt(\"a\".repeat(50));\n      const long = encrypt(\"a\".repeat(200));\n      \n      // Encrypted data length should vary with input length\n      // Base overhead: 32 (salt) + 32 (iv) + 32 (authTag) = 96 hex chars\n      expect(short.length).toBeLessThan(medium.length);\n      expect(medium.length).toBeLessThan(long.length);\n    });\n\n    // Tests to kill StringLiteral mutants for encoding parameters\n    it(\"should produce hex output that differs from base64 encoding\", () => {\n      const originalText = \"test-hex-vs-base64\";\n      const encrypted = encrypt(originalText);\n      \n      // Hex encoding only uses 0-9, a-f characters\n      // If mutated to empty string or other encoding, this would fail\n      expect(encrypted).toMatch(/^[0-9a-f]+$/i);\n      \n      // Hex is 2 chars per byte, so length should be even\n      expect(encrypted.length % 2).toBe(0);\n      \n      // Verify the encrypted portion (after header) is valid hex\n      const encryptedPortion = encrypted.slice(96);\n      expect(encryptedPortion.length).toBeGreaterThan(0);\n      expect(encryptedPortion).toMatch(/^[0-9a-f]+$/i);\n    });\n\n    it(\"should correctly decode utf8 characters after decryption\", () => {\n      // Test various UTF-8 edge cases\n      const testCases = [\n        \"Hello World\",           // ASCII\n        \"HÃ©llo WÃ¶rld\",           // Latin extended\n        \"ä½ å¥½ä¸–ç•Œ\",               // Chinese\n        \"Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…\",         // Arabic\n        \"ðŸŽ‰ðŸ”ðŸ’»\",                // Emoji (4-byte UTF-8)\n        \"Mixed: cafÃ© â˜• æ—¥æœ¬èªž\",  // Mixed scripts\n      ];\n      \n      for (const text of testCases) {\n        const encrypted = encrypt(text);\n        const decrypted = decrypt(encrypted);\n        \n        // Must exactly match - if encoding is wrong, this fails\n        expect(decrypted).toBe(text);\n        \n        // Verify byte-level equality\n        expect(Buffer.from(decrypted, \"utf8\").toString(\"utf8\")).toBe(text);\n      }\n    });\n\n    it(\"should fail with incorrect slice boundaries for auth tag extraction\", () => {\n      const originalText = \"boundary-test\";\n      const encrypted = encrypt(originalText);\n      \n      // Manually verify the exact boundaries\n      // salt: 0-32 (16 bytes * 2 hex chars)\n      // iv: 32-64 (16 bytes * 2 hex chars)\n      // authTag: 64-96 (16 bytes * 2 hex chars)\n      // data: 96+\n      \n      const SALT_LEN = 16;\n      const IV_LEN = 16;\n      const AUTH_TAG_LEN = 16;\n      \n      // Extract using exact same formula as the code\n      const saltEnd = SALT_LEN * 2;\n      const ivEnd = SALT_LEN * 2 + IV_LEN * 2;\n      const authTagEnd = SALT_LEN * 2 + IV_LEN * 2 + AUTH_TAG_LEN * 2;\n      \n      expect(saltEnd).toBe(32);\n      expect(ivEnd).toBe(64);\n      expect(authTagEnd).toBe(96);\n      \n      // Verify boundaries are correct by checking component lengths\n      const salt = encrypted.slice(0, saltEnd);\n      const iv = encrypted.slice(saltEnd, ivEnd);\n      const authTag = encrypted.slice(ivEnd, authTagEnd);\n      const data = encrypted.slice(authTagEnd);\n      \n      expect(salt.length).toBe(32);\n      expect(iv.length).toBe(32);\n      expect(authTag.length).toBe(32);\n      expect(data.length).toBeGreaterThan(0);\n      \n      // If any boundary is wrong (e.g., using / instead of *), decryption fails\n      expect(decrypt(encrypted)).toBe(originalText);\n    });\n\n    it(\"should fail decryption with wrong salt boundary\", () => {\n      const originalText = \"salt-boundary-test\";\n      const encrypted = encrypt(originalText);\n      \n      // Corrupt by using wrong salt length (simulates SALT_LENGTH / 2 mutation)\n      const wrongSalt = encrypted.slice(0, 16); // Only 8 bytes instead of 16\n      const rest = encrypted.slice(32);\n      const corrupted = wrongSalt + \"00\".repeat(8) + rest;\n      \n      expect(() => decrypt(corrupted)).toThrow();\n    });\n\n    it(\"should fail decryption with wrong IV boundary\", () => {\n      const originalText = \"iv-boundary-test\";\n      const encrypted = encrypt(originalText);\n      \n      // Corrupt by shifting IV boundary (simulates IV_LENGTH / 2 mutation)\n      const salt = encrypted.slice(0, 32);\n      const wrongIv = encrypted.slice(32, 48); // Only 8 bytes instead of 16\n      const authTagAndData = encrypted.slice(64);\n      const corrupted = salt + wrongIv + \"00\".repeat(8) + authTagAndData;\n      \n      expect(() => decrypt(corrupted)).toThrow();\n    });\n\n    it(\"should fail decryption with wrong authTag boundary\", () => {\n      const originalText = \"authtag-boundary-test\";\n      const encrypted = encrypt(originalText);\n      \n      // Corrupt by using wrong authTag length (simulates AUTH_TAG_LENGTH / 2 mutation)\n      const header = encrypted.slice(0, 64); // salt + iv\n      const wrongAuthTag = encrypted.slice(64, 80); // Only 8 bytes instead of 16\n      const data = encrypted.slice(96);\n      const corrupted = header + wrongAuthTag + \"00\".repeat(8) + data;\n      \n      expect(() => decrypt(corrupted)).toThrow();\n    });\n\n    it(\"should handle the default encryption key fallback\", () => {\n      // This test verifies the || operator works correctly\n      // When JWT_SECRET is undefined, it should use the default key\n      // The encrypt/decrypt cycle should still work\n      const originalText = \"fallback-key-test\";\n      const encrypted = encrypt(originalText);\n      const decrypted = decrypt(encrypted);\n      \n      expect(decrypted).toBe(originalText);\n      \n      // Verify encryption actually happened (not passthrough)\n      expect(encrypted).not.toBe(originalText);\n      expect(encrypted.length).toBeGreaterThan(originalText.length);\n    });\n\n    it(\"should produce consistent results with the same key\", () => {\n      // Multiple encrypt/decrypt cycles should all work\n      const texts = [\"key1\", \"key2\", \"key3\", \"key4\", \"key5\"];\n      const encrypted = texts.map(t => encrypt(t));\n      const decrypted = encrypted.map(e => decrypt(e));\n      \n      expect(decrypted).toEqual(texts);\n    });\n  });\n\n  describe(\"getKeyHint\", () => {\n    it(\"should return last 4 characters of API key\", () => {\n      expect(getKeyHint(\"sk-test-api-key-12345\")).toBe(\"2345\");\n    });\n\n    it(\"should return **** for keys shorter than 4 characters\", () => {\n      expect(getKeyHint(\"abc\")).toBe(\"****\");\n      expect(getKeyHint(\"ab\")).toBe(\"****\");\n      expect(getKeyHint(\"a\")).toBe(\"****\");\n    });\n\n    it(\"should return last 4 chars for exactly 4 character key\", () => {\n      expect(getKeyHint(\"abcd\")).toBe(\"abcd\");\n    });\n  });\n\n  describe(\"maskApiKey\", () => {\n    it(\"should mask middle of API key\", () => {\n      expect(maskApiKey(\"sk-test-api-key-12345\")).toBe(\"sk-t...2345\");\n    });\n\n    it(\"should return **** for keys 8 characters or shorter\", () => {\n      expect(maskApiKey(\"12345678\")).toBe(\"****\");\n      expect(maskApiKey(\"1234567\")).toBe(\"****\");\n      expect(maskApiKey(\"short\")).toBe(\"****\");\n    });\n\n    it(\"should show first 4 and last 4 for longer keys\", () => {\n      expect(maskApiKey(\"123456789\")).toBe(\"1234...6789\");\n    });\n  });\n});\n"},"server/phase4.test.ts":{"tests":[{"id":"26","name":"Phase 4 Features sessions.create with completion criteria creates a session with completion criteria"},{"id":"27","name":"Phase 4 Features sessions.update with status changes updates session status to paused"},{"id":"28","name":"Phase 4 Features sessions.list returns user sessions returns an array of sessions"},{"id":"29","name":"Phase 4 Features prompts.save stores prompt data saves a prompt with all fields"},{"id":"30","name":"Phase 4 Features prompts.list returns user prompts returns an array of prompts"},{"id":"31","name":"Session Export/Import Schema validates session export schema structure"}],"source":"import { describe, expect, it, vi } from \"vitest\";\nimport { appRouter } from \"./routers\";\nimport type { TrpcContext } from \"./_core/context\";\n\ntype CookieCall = {\n  name: string;\n  options: Record<string, unknown>;\n};\n\ntype AuthenticatedUser = NonNullable<TrpcContext[\"user\"]>;\n\nfunction createAuthContext(): { ctx: TrpcContext; clearedCookies: CookieCall[] } {\n  const clearedCookies: CookieCall[] = [];\n\n  const user: AuthenticatedUser = {\n    id: 1,\n    openId: \"test-user-phase4\",\n    email: \"phase4@example.com\",\n    name: \"Phase 4 Test User\",\n    loginMethod: \"manus\",\n    role: \"user\",\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    lastSignedIn: new Date(),\n  };\n\n  const ctx: TrpcContext = {\n    user,\n    req: {\n      protocol: \"https\",\n      headers: {},\n    } as TrpcContext[\"req\"],\n    res: {\n      clearCookie: (name: string, options: Record<string, unknown>) => {\n        clearedCookies.push({ name, options });\n      },\n    } as TrpcContext[\"res\"],\n  };\n\n  return { ctx, clearedCookies };\n}\n\ndescribe(\"Phase 4 Features\", () => {\n  describe(\"sessions.create with completion criteria\", () => {\n    it(\"creates a session with completion criteria\", async () => {\n      const { ctx } = createAuthContext();\n      const caller = appRouter.createCaller(ctx);\n\n      const result = await caller.sessions.create({\n        model: \"claude\",\n        profile: \"patch_goblin\",\n        workingDirectory: \"/home/ubuntu/test-project\",\n        maxIterations: 50,\n        completionCriteria: JSON.stringify([\n          { id: \"1\", text: \"All tests pass\", completed: false },\n          { id: \"2\", text: \"Build succeeds\", completed: false },\n        ]),\n      });\n\n      expect(result).toBeDefined();\n      expect(result.sessionId).toBeDefined();\n      expect(typeof result.sessionId).toBe(\"string\");\n    });\n  });\n\n  describe(\"sessions.update with status changes\", () => {\n    it(\"updates session status to paused\", async () => {\n      const { ctx } = createAuthContext();\n      const caller = appRouter.createCaller(ctx);\n\n      // First create a session\n      const createResult = await caller.sessions.create({\n        model: \"claude\",\n        profile: \"architect_owl\",\n        workingDirectory: \"/home/ubuntu/test-project-2\",\n        maxIterations: 25,\n      });\n\n      // Then update its status\n      const updateResult = await caller.sessions.update({\n        sessionId: createResult.sessionId,\n        updates: { status: \"paused\" },\n      });\n\n      expect(updateResult).toBeDefined();\n      expect(updateResult.success).toBe(true);\n    });\n  });\n\n  describe(\"sessions.list returns user sessions\", () => {\n    it(\"returns an array of sessions\", async () => {\n      const { ctx } = createAuthContext();\n      const caller = appRouter.createCaller(ctx);\n\n      const result = await caller.sessions.list();\n\n      expect(result).toBeDefined();\n      expect(Array.isArray(result)).toBe(true);\n    });\n  });\n\n  describe(\"prompts.save stores prompt data\", () => {\n    it(\"saves a prompt with all fields\", async () => {\n      const { ctx } = createAuthContext();\n      const caller = appRouter.createCaller(ctx);\n\n      const result = await caller.prompts.save({\n        name: \"REST API Build Prompt\",\n        goal: \"Build a REST API\",\n        context: \"Using Express.js and TypeScript\",\n        doneWhen: \"All endpoints return correct responses\",\n        doNot: \"Use deprecated packages\",\n        expandedPrompt: \"Full expanded prompt text here...\",\n        targetModel: \"claude\",\n      });\n\n      expect(result).toBeDefined();\n      expect(result.success).toBe(true);\n    });\n  });\n\n  describe(\"prompts.list returns user prompts\", () => {\n    it(\"returns an array of prompts\", async () => {\n      const { ctx } = createAuthContext();\n      const caller = appRouter.createCaller(ctx);\n\n      const result = await caller.prompts.list();\n\n      expect(result).toBeDefined();\n      expect(Array.isArray(result)).toBe(true);\n    });\n  });\n});\n\ndescribe(\"Session Export/Import Schema\", () => {\n  it(\"validates session export schema structure\", () => {\n    const exportData = {\n      version: \"1.0.0\",\n      exportedAt: new Date().toISOString(),\n      session: {\n        name: \"Test Session\",\n        model: \"claude\",\n        profile: \"patch_goblin\",\n        workingDirectory: \"/home/ubuntu\",\n        maxIterations: 50,\n        noProgressThreshold: 3,\n        circuitBreakerEnabled: true,\n        dangerouslySkipPermissions: true,\n      },\n      completionCriteria: [\n        { id: \"1\", text: \"All tests pass\", completed: false },\n        { id: \"2\", text: \"Build succeeds\", completed: true },\n      ],\n    };\n\n    expect(exportData.version).toBe(\"1.0.0\");\n    expect(exportData.session.model).toBe(\"claude\");\n    expect(exportData.completionCriteria).toHaveLength(2);\n    expect(exportData.completionCriteria[1].completed).toBe(true);\n  });\n});\n"},"server/apiKeys.test.ts":{"tests":[{"id":"32","name":"apiKeys router saves an API key and returns key hint"},{"id":"33","name":"apiKeys router lists user API keys without exposing actual keys"},{"id":"34","name":"apiKeys router gets API key metadata for a specific provider"},{"id":"35","name":"apiKeys router validates Claude API key format"},{"id":"36","name":"apiKeys router deletes an API key"},{"id":"37","name":"sessions router creates a new session with startLoop"}],"source":"import { describe, expect, it, vi, beforeEach } from \"vitest\";\nimport { appRouter } from \"./routers\";\nimport type { TrpcContext } from \"./_core/context\";\n\n// Mock the database functions\nvi.mock(\"./db\", () => ({\n  saveApiKey: vi.fn().mockResolvedValue({}),\n  getUserApiKeys: vi.fn().mockResolvedValue([\n    { id: 1, provider: \"claude\", keyHint: \"abc1\", isValid: true, createdAt: new Date() },\n    { id: 2, provider: \"codex\", keyHint: \"xyz2\", isValid: true, createdAt: new Date() },\n  ]),\n  getApiKeyForProvider: vi.fn().mockResolvedValue({\n    id: 1,\n    provider: \"claude\",\n    encryptedKey: \"mock-encrypted\",\n    keyHint: \"abc1\",\n    isValid: true,\n  }),\n  deleteApiKey: vi.fn().mockResolvedValue({}),\n  updateApiKeyValidity: vi.fn().mockResolvedValue({}),\n}));\n\n// Mock crypto functions\nvi.mock(\"./crypto\", () => ({\n  encrypt: vi.fn().mockReturnValue(\"encrypted-key-data\"),\n  decrypt: vi.fn().mockReturnValue(\"sk-ant-test-key-abc1\"),\n  getKeyHint: vi.fn().mockReturnValue(\"abc1\"),\n}));\n\ntype AuthenticatedUser = NonNullable<TrpcContext[\"user\"]>;\n\nfunction createAuthContext(): TrpcContext {\n  const user: AuthenticatedUser = {\n    id: 1,\n    openId: \"test-user\",\n    email: \"test@example.com\",\n    name: \"Test User\",\n    loginMethod: \"manus\",\n    role: \"user\",\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    lastSignedIn: new Date(),\n  };\n\n  return {\n    user,\n    req: {\n      protocol: \"https\",\n      headers: {},\n    } as TrpcContext[\"req\"],\n    res: {\n      clearCookie: vi.fn(),\n    } as unknown as TrpcContext[\"res\"],\n  };\n}\n\ndescribe(\"apiKeys router\", () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it(\"saves an API key and returns key hint\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.apiKeys.save({\n      provider: \"claude\",\n      apiKey: \"sk-ant-test-key-abc1\",\n    });\n\n    expect(result).toEqual({ success: true, keyHint: \"abc1\" });\n  });\n\n  it(\"lists user API keys without exposing actual keys\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.apiKeys.list();\n\n    expect(result.length).toBeGreaterThanOrEqual(1);\n    expect(result[0]).toHaveProperty(\"provider\");\n    expect(result[0]).toHaveProperty(\"keyHint\");\n    expect(result[0]).not.toHaveProperty(\"encryptedKey\");\n  });\n\n  it(\"gets API key metadata for a specific provider\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.apiKeys.getForProvider({ provider: \"claude\" });\n\n    expect(result).not.toBeNull();\n    expect(result?.provider).toBe(\"claude\");\n    expect(result?.keyHint).toBe(\"abc1\");\n    expect(result?.isValid).toBe(true);\n  });\n\n  it(\"validates Claude API key format\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.apiKeys.validate({ provider: \"claude\" });\n\n    expect(result.valid).toBe(true);\n  });\n\n  it(\"deletes an API key\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.apiKeys.delete({ id: 1 });\n\n    expect(result).toEqual({ success: true });\n  });\n});\n\ndescribe(\"sessions router\", () => {\n  it(\"creates a new session with startLoop\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    // Mock the session creation\n    vi.mock(\"./db\", async (importOriginal) => {\n      const actual = await importOriginal() as Record<string, unknown>;\n      return {\n        ...actual,\n        createSession: vi.fn().mockResolvedValue({}),\n        getSessionBySessionId: vi.fn().mockResolvedValue({\n          id: 1,\n          sessionId: \"session-test123\",\n          userId: 1,\n          status: \"running\",\n        }),\n      };\n    });\n\n    const result = await caller.sessions.startLoop({\n      config: {\n        name: \"Test Session\",\n        ralphMode: true,\n        maxIterations: 50,\n        noProgressThreshold: 3,\n        autoAskHuman: true,\n        safetyMode: \"standard\",\n        selectedModel: \"claude\",\n        selectedProfile: \"patch_goblin\",\n      },\n      prompt: \"Build a todo app\",\n      workingDirectory: \"/home/ubuntu/test-project\",\n    });\n\n    expect(result).toHaveProperty(\"sessionId\");\n    expect(result.sessionId).toMatch(/^session-/);\n    expect(result).toHaveProperty(\"message\");\n  });\n});\n"},"server/phase5.test.ts":{"tests":[{"id":"38","name":"Phase 5: Analytics Data sessions.list returns array for analytics processing"},{"id":"39","name":"Phase 5: Analytics Data sessions.create returns sessionId"},{"id":"40","name":"Phase 5: Prompt Templates prompts.list returns array for template library"},{"id":"41","name":"Phase 5: Prompt Templates prompts.save creates a new template"},{"id":"42","name":"Phase 5: Prompt Templates prompts can be listed after creation"},{"id":"43","name":"Phase 5: CLI Integration sessions can be created for CLI execution"},{"id":"44","name":"Phase 5: CLI Integration sessions can be updated with iteration progress"}],"source":"import { describe, expect, it, vi } from \"vitest\";\nimport { appRouter } from \"./routers\";\nimport type { TrpcContext } from \"./_core/context\";\n\n// Mock authenticated user context\nfunction createAuthContext(): TrpcContext {\n  return {\n    user: {\n      id: 1,\n      openId: \"test-user\",\n      email: \"test@example.com\",\n      name: \"Test User\",\n      loginMethod: \"manus\",\n      role: \"user\",\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      lastSignedIn: new Date(),\n    },\n    req: {\n      protocol: \"https\",\n      headers: {},\n    } as TrpcContext[\"req\"],\n    res: {\n      clearCookie: vi.fn(),\n    } as unknown as TrpcContext[\"res\"],\n  };\n}\n\ndescribe(\"Phase 5: Analytics Data\", () => {\n  it(\"sessions.list returns array for analytics processing\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n    \n    // List sessions - should return array (possibly empty)\n    const sessions = await caller.sessions.list();\n    \n    expect(Array.isArray(sessions)).toBe(true);\n  });\n  \n  it(\"sessions.create returns sessionId\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n    \n    // Create a test session\n    const result = await caller.sessions.create({\n      name: \"Analytics Test Session\",\n      selectedModel: \"claude\",\n      agentProfile: \"patch_goblin\",\n      workingDirectory: \"/test/path\",\n    });\n    \n    // Verify session creation returns sessionId\n    expect(result).toHaveProperty(\"sessionId\");\n    expect(typeof result.sessionId).toBe(\"string\");\n  });\n});\n\ndescribe(\"Phase 5: Prompt Templates\", () => {\n  it(\"prompts.list returns array for template library\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n    \n    // List prompts - should return array\n    const prompts = await caller.prompts.list();\n    \n    expect(Array.isArray(prompts)).toBe(true);\n  });\n  \n  it(\"prompts.save creates a new template\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n    \n    // Save a new prompt template\n    const result = await caller.prompts.save({\n      name: \"Test Template\",\n      goal: \"Build a test component\",\n      context: \"React + TypeScript\",\n      doneWhen: \"Tests pass\",\n      doNot: \"Skip types\",\n      expandedPrompt: \"react, typescript, testing\",\n    });\n    \n    // prompts.save returns { success: true }\n    expect(result).toHaveProperty(\"success\", true);\n  });\n  \n  it(\"prompts can be listed after creation\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n    \n    // First create a prompt\n    await caller.prompts.save({\n      name: \"Template to List\",\n      goal: \"Test listing\",\n      context: \"\",\n      doneWhen: \"\",\n      doNot: \"\",\n      expandedPrompt: \"\",\n    });\n    \n    // Then list prompts\n    const prompts = await caller.prompts.list();\n    \n    // Should have at least one prompt\n    expect(Array.isArray(prompts)).toBe(true);\n  });\n});\n\ndescribe(\"Phase 5: CLI Integration\", () => {\n  it(\"sessions can be created for CLI execution\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n    \n    // Create a session\n    const result = await caller.sessions.create({\n      name: \"CLI Test Session\",\n      selectedModel: \"claude\",\n      agentProfile: \"patch_goblin\",\n      workingDirectory: \"/test/cli\",\n    });\n    \n    // Session should be created and return sessionId\n    expect(result).toHaveProperty(\"sessionId\");\n    expect(result.sessionId).toMatch(/^session-/);\n  });\n  \n  it(\"sessions can be updated with iteration progress\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n    \n    // Create a session first\n    const created = await caller.sessions.create({\n      name: \"Iteration Test\",\n      selectedModel: \"claude\",\n      agentProfile: \"test_gremlin\",\n      workingDirectory: \"/test/iter\",\n    });\n    \n    // Update the session using correct schema\n    const updated = await caller.sessions.update({\n      sessionId: created.sessionId,\n      updates: {\n        currentIteration: 5,\n        completionProgress: 60,\n        status: \"running\",\n      },\n    });\n    \n    expect(updated.success).toBe(true);\n  });\n});\n"},"server/session.test.ts":{"tests":[{"id":"45","name":"auth router auth.me returns user when authenticated"},{"id":"46","name":"auth router auth.me returns null when not authenticated"},{"id":"47","name":"sessions router schema validation sessions.create validates input schema correctly"},{"id":"48","name":"sessions router schema validation sessions.list is defined for authenticated users"},{"id":"49","name":"criteria router structure criteria router has expected procedures"},{"id":"50","name":"metrics router structure metrics router has expected procedures"},{"id":"51","name":"assemblyLine router structure assemblyLine router has expected procedures"},{"id":"52","name":"diffHunks router structure diffHunks router has expected procedures"},{"id":"53","name":"checkpoints router structure checkpoints router has expected procedures"}],"source":"import { describe, expect, it } from \"vitest\";\nimport { appRouter } from \"./routers\";\nimport type { TrpcContext } from \"./_core/context\";\n\ntype AuthenticatedUser = NonNullable<TrpcContext[\"user\"]>;\n\nfunction createAuthContext(): { ctx: TrpcContext } {\n  const user: AuthenticatedUser = {\n    id: 1,\n    openId: \"test-user-123\",\n    email: \"test@example.com\",\n    name: \"Test User\",\n    loginMethod: \"manus\",\n    role: \"user\",\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    lastSignedIn: new Date(),\n  };\n\n  const ctx: TrpcContext = {\n    user,\n    req: {\n      protocol: \"https\",\n      headers: {},\n    } as TrpcContext[\"req\"],\n    res: {\n      clearCookie: () => {},\n    } as TrpcContext[\"res\"],\n  };\n\n  return { ctx };\n}\n\nfunction createPublicContext(): { ctx: TrpcContext } {\n  const ctx: TrpcContext = {\n    user: null,\n    req: {\n      protocol: \"https\",\n      headers: {},\n    } as TrpcContext[\"req\"],\n    res: {\n      clearCookie: () => {},\n    } as TrpcContext[\"res\"],\n  };\n\n  return { ctx };\n}\n\ndescribe(\"auth router\", () => {\n  it(\"auth.me returns user when authenticated\", async () => {\n    const { ctx } = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.auth.me();\n\n    expect(result).not.toBeNull();\n    expect(result?.openId).toBe(\"test-user-123\");\n    expect(result?.email).toBe(\"test@example.com\");\n  });\n\n  it(\"auth.me returns null when not authenticated\", async () => {\n    const { ctx } = createPublicContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.auth.me();\n\n    expect(result).toBeNull();\n  });\n});\n\ndescribe(\"sessions router schema validation\", () => {\n  it(\"sessions.create validates input schema correctly\", async () => {\n    const { ctx } = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    // Test that the router exists and accepts valid input\n    // We don't actually run the mutation since it requires DB\n    expect(caller.sessions).toBeDefined();\n    expect(caller.sessions.create).toBeDefined();\n  });\n\n  it(\"sessions.list is defined for authenticated users\", async () => {\n    const { ctx } = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    expect(caller.sessions.list).toBeDefined();\n  });\n});\n\ndescribe(\"criteria router structure\", () => {\n  it(\"criteria router has expected procedures\", async () => {\n    const { ctx } = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    expect(caller.criteria).toBeDefined();\n    expect(caller.criteria.add).toBeDefined();\n    expect(caller.criteria.list).toBeDefined();\n    expect(caller.criteria.toggle).toBeDefined();\n    expect(caller.criteria.delete).toBeDefined();\n  });\n});\n\ndescribe(\"metrics router structure\", () => {\n  it(\"metrics router has expected procedures\", async () => {\n    const { ctx } = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    expect(caller.metrics).toBeDefined();\n    expect(caller.metrics.add).toBeDefined();\n    expect(caller.metrics.list).toBeDefined();\n  });\n});\n\ndescribe(\"assemblyLine router structure\", () => {\n  it(\"assemblyLine router has expected procedures\", async () => {\n    const { ctx } = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    expect(caller.assemblyLine).toBeDefined();\n    expect(caller.assemblyLine.create).toBeDefined();\n    expect(caller.assemblyLine.list).toBeDefined();\n    expect(caller.assemblyLine.update).toBeDefined();\n  });\n});\n\ndescribe(\"diffHunks router structure\", () => {\n  it(\"diffHunks router has expected procedures\", async () => {\n    const { ctx } = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    expect(caller.diffHunks).toBeDefined();\n    expect(caller.diffHunks.add).toBeDefined();\n    expect(caller.diffHunks.list).toBeDefined();\n    expect(caller.diffHunks.approve).toBeDefined();\n  });\n});\n\ndescribe(\"checkpoints router structure\", () => {\n  it(\"checkpoints router has expected procedures\", async () => {\n    const { ctx } = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    expect(caller.checkpoints).toBeDefined();\n    expect(caller.checkpoints.create).toBeDefined();\n    expect(caller.checkpoints.list).toBeDefined();\n    expect(caller.checkpoints.latest).toBeDefined();\n  });\n});\n"},"server/phase6.test.ts":{"tests":[{"id":"54","name":"Phase 6: Prompt Library can save a prompt template with tags"},{"id":"55","name":"Phase 6: Prompt Library can list all saved prompts"},{"id":"56","name":"Phase 6: Session Management can create a new session"},{"id":"57","name":"Phase 6: Session Management can list all sessions"},{"id":"58","name":"Phase 6: Session Management can get session analytics"},{"id":"59","name":"Phase 6: Multi-Session View sessions list returns data for multi-session view"}],"source":"import { describe, expect, it } from \"vitest\";\nimport { appRouter } from \"./routers\";\nimport type { TrpcContext } from \"./_core/context\";\n\ntype AuthenticatedUser = NonNullable<TrpcContext[\"user\"]>;\n\nfunction createAuthContext(): { ctx: TrpcContext } {\n  const user: AuthenticatedUser = {\n    id: 1,\n    openId: \"test-user-phase6\",\n    email: \"test@example.com\",\n    name: \"Test User\",\n    loginMethod: \"manus\",\n    role: \"user\",\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    lastSignedIn: new Date(),\n  };\n\n  const ctx: TrpcContext = {\n    user,\n    req: {\n      protocol: \"https\",\n      headers: {},\n    } as TrpcContext[\"req\"],\n    res: {\n      clearCookie: () => {},\n    } as TrpcContext[\"res\"],\n  };\n\n  return { ctx };\n}\n\ndescribe(\"Phase 6: Prompt Library\", () => {\n  it(\"can save a prompt template with tags\", async () => {\n    const { ctx } = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.prompts.save({\n      name: \"React Component Builder\",\n      goal: \"Build a reusable React component\",\n      context: \"Using TypeScript and Tailwind CSS\",\n      doneWhen: \"Component renders correctly with props\",\n      doNot: \"Use class components\",\n      tags: [\"react\", \"typescript\", \"tailwind\"],\n    });\n\n    expect(result).toBeDefined();\n    expect(result.success).toBe(true);\n  });\n\n  it(\"can list all saved prompts\", async () => {\n    const { ctx } = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.prompts.list();\n\n    expect(result).toBeDefined();\n    expect(Array.isArray(result)).toBe(true);\n  });\n});\n\ndescribe(\"Phase 6: Session Management\", () => {\n  it(\"can create a new session\", async () => {\n    const { ctx } = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.sessions.create({\n      model: \"claude\",\n      workingDirectory: \"/home/ubuntu/test-project\",\n      prompt: \"Build a todo app\",\n      completionCriteria: [\"Tests pass\", \"UI renders\"],\n    });\n\n    expect(result).toBeDefined();\n    expect(result.sessionId).toBeDefined();\n  });\n\n  it(\"can list all sessions\", async () => {\n    const { ctx } = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.sessions.list();\n\n    expect(result).toBeDefined();\n    expect(Array.isArray(result)).toBe(true);\n  });\n\n  it(\"can get session analytics\", async () => {\n    const { ctx } = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    // Analytics is computed on the frontend from session list data\n    const sessions = await caller.sessions.list();\n    expect(sessions).toBeDefined();\n    expect(Array.isArray(sessions)).toBe(true);\n    \n    // Compute analytics from sessions\n    const totalSessions = sessions.length;\n    const completedSessions = sessions.filter((s: any) => s.status === 'complete').length;\n    const successRate = totalSessions > 0 ? (completedSessions / totalSessions) * 100 : 0;\n    \n    expect(totalSessions).toBeGreaterThanOrEqual(0);\n    expect(successRate).toBeGreaterThanOrEqual(0);\n  });\n});\n\ndescribe(\"Phase 6: Multi-Session View\", () => {\n  it(\"sessions list returns data for multi-session view\", async () => {\n    const { ctx } = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const sessions = await caller.sessions.list();\n\n    // Multi-session view needs session data with status\n    expect(Array.isArray(sessions)).toBe(true);\n    if (sessions.length > 0) {\n      expect(sessions[0]).toHaveProperty(\"status\");\n      // Model is stored in selectedModel field\n      expect(sessions[0]).toHaveProperty(\"selectedModel\");\n    }\n  });\n});\n"},"server/sessionTemplates.test.ts":{"tests":[{"id":"60","name":"sessionTemplates router should create a new session template"},{"id":"61","name":"sessionTemplates router should list session templates"},{"id":"62","name":"sessionTemplates router should track template usage"},{"id":"63","name":"sessionTemplates router should delete a session template"}],"source":"import { describe, expect, it } from \"vitest\";\nimport { appRouter } from \"./routers\";\nimport type { TrpcContext } from \"./_core/context\";\n\ntype AuthenticatedUser = NonNullable<TrpcContext[\"user\"]>;\n\nfunction createAuthContext(): TrpcContext {\n  const user: AuthenticatedUser = {\n    id: 1,\n    openId: \"test-user-123\",\n    email: \"test@example.com\",\n    name: \"Test User\",\n    loginMethod: \"manus\",\n    role: \"user\",\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    lastSignedIn: new Date(),\n  };\n\n  return {\n    user,\n    req: {\n      protocol: \"https\",\n      headers: {},\n    } as TrpcContext[\"req\"],\n    res: {\n      clearCookie: () => {},\n    } as TrpcContext[\"res\"],\n  };\n}\n\ndescribe(\"sessionTemplates router\", () => {\n  it(\"should create a new session template\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.sessionTemplates.create({\n      name: \"Test Template\",\n      description: \"A test session template\",\n      tags: [\"test\", \"demo\"],\n      selectedModel: \"claude\",\n      selectedProfile: \"patch_goblin\",\n      ralphMode: true,\n      maxIterations: 50,\n      noProgressThreshold: 3,\n      autoAskHuman: true,\n      safetyMode: \"standard\",\n      promptGoal: \"Build a test feature\",\n      promptContext: \"Testing context\",\n      promptDoneWhen: \"All tests pass\",\n      promptDoNot: \"Don't break things\",\n      completionCriteria: [\"Tests pass\", \"Build succeeds\"],\n    });\n\n    expect(result).toBeDefined();\n    expect(result.id).toBeDefined();\n    expect(result.name).toBe(\"Test Template\");\n  });\n\n  it(\"should list session templates\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.sessionTemplates.list();\n\n    expect(result).toBeDefined();\n    expect(Array.isArray(result)).toBe(true);\n  });\n\n  it(\"should track template usage\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    // First create a template\n    const created = await caller.sessionTemplates.create({\n      name: \"Usage Test Template\",\n      description: \"Testing usage tracking\",\n      tags: [\"usage-test\"],\n      selectedModel: \"gemini\",\n      selectedProfile: \"architect_owl\",\n      ralphMode: false,\n      maxIterations: 25,\n      noProgressThreshold: 5,\n      autoAskHuman: false,\n      safetyMode: \"strict\",\n    });\n\n    // Then use it\n    const used = await caller.sessionTemplates.use({ id: created.id });\n\n    expect(used).toBeDefined();\n    expect(used.name).toBe(\"Usage Test Template\");\n    expect(used.usageCount).toBeGreaterThanOrEqual(1);\n  });\n\n  it(\"should delete a session template\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    // First create a template\n    const created = await caller.sessionTemplates.create({\n      name: \"Delete Test Template\",\n      description: \"Will be deleted\",\n      tags: [\"delete-test\"],\n      selectedModel: \"codex\",\n      selectedProfile: \"test_gremlin\",\n      ralphMode: true,\n      maxIterations: 100,\n      noProgressThreshold: 2,\n      autoAskHuman: true,\n      safetyMode: \"permissive\",\n    });\n\n    // Then delete it\n    const result = await caller.sessionTemplates.delete({ id: created.id });\n\n    expect(result).toEqual({ success: true });\n  });\n});\n"},"server/sessionHistory.test.ts":{"tests":[{"id":"64","name":"sessions router list returns array when called"},{"id":"65","name":"sessions router create returns a new session with sessionId"},{"id":"66","name":"apiKeys router list returns array of API keys"},{"id":"67","name":"prompts router list returns array of prompts"},{"id":"68","name":"prompts router save creates a new prompt and returns success"}],"source":"import { describe, expect, it, vi } from \"vitest\";\nimport { appRouter } from \"./routers\";\nimport type { TrpcContext } from \"./_core/context\";\n\ntype AuthenticatedUser = NonNullable<TrpcContext[\"user\"]>;\n\nfunction createAuthContext(): TrpcContext {\n  const user: AuthenticatedUser = {\n    id: 1,\n    openId: \"test-user-123\",\n    email: \"test@example.com\",\n    name: \"Test User\",\n    loginMethod: \"manus\",\n    role: \"user\",\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    lastSignedIn: new Date(),\n  };\n\n  return {\n    user,\n    req: {\n      protocol: \"https\",\n      headers: {},\n    } as TrpcContext[\"req\"],\n    res: {\n      clearCookie: vi.fn(),\n    } as unknown as TrpcContext[\"res\"],\n  };\n}\n\ndescribe(\"sessions router\", () => {\n  it(\"list returns array when called\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.sessions.list();\n    \n    expect(result).toBeDefined();\n    expect(Array.isArray(result)).toBe(true);\n  });\n\n  it(\"create returns a new session with sessionId\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    // Use the correct schema matching sessionConfigSchema\n    const result = await caller.sessions.create({\n      selectedModel: \"claude\",\n      selectedProfile: \"patch_goblin\",\n      maxIterations: 10,\n      ralphMode: true,\n      noProgressThreshold: 3,\n      autoAskHuman: true,\n      safetyMode: \"standard\",\n    });\n\n    expect(result).toBeDefined();\n    expect(result.sessionId).toBeDefined();\n    expect(typeof result.sessionId).toBe(\"string\");\n    expect(result.sessionId).toMatch(/^session-/);\n  });\n});\n\ndescribe(\"apiKeys router\", () => {\n  it(\"list returns array of API keys\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.apiKeys.list();\n    \n    expect(result).toBeDefined();\n    expect(Array.isArray(result)).toBe(true);\n  });\n});\n\ndescribe(\"prompts router\", () => {\n  it(\"list returns array of prompts\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.prompts.list();\n    \n    expect(result).toBeDefined();\n    expect(Array.isArray(result)).toBe(true);\n  });\n\n  it(\"save creates a new prompt and returns success\", async () => {\n    const ctx = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.prompts.save({\n      name: \"Test Prompt\",\n      goal: \"Build a test feature\",\n      context: \"Testing context\",\n      doneWhen: \"All tests pass\",\n      doNot: \"Do not break existing code\",\n      targetModel: \"claude\",\n    });\n    \n    expect(result).toBeDefined();\n    expect(result.success).toBe(true);\n  });\n});\n"},"server/auth.logout.test.ts":{"tests":[{"id":"69","name":"auth.logout clears the session cookie and reports success"}],"source":"import { describe, expect, it } from \"vitest\";\nimport { appRouter } from \"./routers\";\nimport { COOKIE_NAME } from \"../shared/const\";\nimport type { TrpcContext } from \"./_core/context\";\n\ntype CookieCall = {\n  name: string;\n  options: Record<string, unknown>;\n};\n\ntype AuthenticatedUser = NonNullable<TrpcContext[\"user\"]>;\n\nfunction createAuthContext(): { ctx: TrpcContext; clearedCookies: CookieCall[] } {\n  const clearedCookies: CookieCall[] = [];\n\n  const user: AuthenticatedUser = {\n    id: 1,\n    openId: \"sample-user\",\n    email: \"sample@example.com\",\n    name: \"Sample User\",\n    loginMethod: \"manus\",\n    role: \"user\",\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    lastSignedIn: new Date(),\n  };\n\n  const ctx: TrpcContext = {\n    user,\n    req: {\n      protocol: \"https\",\n      headers: {},\n    } as TrpcContext[\"req\"],\n    res: {\n      clearCookie: (name: string, options: Record<string, unknown>) => {\n        clearedCookies.push({ name, options });\n      },\n    } as TrpcContext[\"res\"],\n  };\n\n  return { ctx, clearedCookies };\n}\n\ndescribe(\"auth.logout\", () => {\n  it(\"clears the session cookie and reports success\", async () => {\n    const { ctx, clearedCookies } = createAuthContext();\n    const caller = appRouter.createCaller(ctx);\n\n    const result = await caller.auth.logout();\n\n    expect(result).toEqual({ success: true });\n    expect(clearedCookies).toHaveLength(1);\n    expect(clearedCookies[0]?.name).toBe(COOKIE_NAME);\n    expect(clearedCookies[0]?.options).toMatchObject({\n      maxAge: -1,\n      secure: true,\n      sameSite: \"none\",\n      httpOnly: true,\n      path: \"/\",\n    });\n  });\n});\n"}},"projectRoot":"/home/ubuntu/coding-wheel","config":{"$schema":"https://raw.githubusercontent.com/stryker-mutator/stryker/master/packages/core/schema/stryker-schema.json","packageManager":"pnpm","plugins":["@stryker-mutator/vitest-runner"],"testRunner":"vitest","mutate":["server/crypto.ts"],"ignorePatterns":["node_modules","dist","coverage",".stryker-tmp","client"],"reporters":["html","clear-text","progress","json"],"htmlReporter":{"fileName":"reports/mutation/mutation-report.html"},"jsonReporter":{"fileName":"reports/mutation/mutation-report.json"},"thresholds":{"high":80,"low":60,"break":40},"concurrency":1,"timeoutMS":60000,"timeoutFactor":2.5,"cleanTempDir":"always","logLevel":"info","incremental":true,"incrementalFile":".stryker-incremental.json","allowConsoleColors":true,"checkers":[],"checkerNodeArgs":[],"commandRunner":{"command":"npm test"},"coverageAnalysis":"perTest","clearTextReporter":{"allowColor":true,"allowEmojis":false,"logTests":true,"maxTestsToLog":3,"reportTests":true,"reportMutants":true,"reportScoreTable":true,"skipFull":false},"dashboard":{"baseUrl":"https://dashboard.stryker-mutator.io/api/reports","reportType":"full"},"dryRunOnly":false,"eventReporter":{"baseDir":"reports/mutation/events"},"ignoreStatic":false,"force":false,"fileLogLevel":"off","inPlace":false,"maxConcurrentTestRunners":9007199254740991,"maxTestRunnerReuse":0,"mutator":{"plugins":null,"excludedMutations":[]},"appendPlugins":[],"disableTypeChecks":true,"symlinkNodeModules":true,"tempDirName":".stryker-tmp","testRunnerNodeArgs":[],"dryRunTimeoutMinutes":5,"tsconfigFile":"tsconfig.json","warnings":true,"disableBail":false,"allowEmpty":false,"ignorers":[],"vitest":{"related":true}},"framework":{"name":"StrykerJS","version":"9.4.0","branding":{"homepageUrl":"https://stryker-mutator.io","imageUrl":"data:image/svg+xml;utf8,%3Csvg viewBox='0 0 1458 1458' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' clip-rule='evenodd' stroke-linejoin='round' stroke-miterlimit='2'%3E%3Cpath fill='none' d='M0 0h1458v1458H0z'/%3E%3CclipPath id='a'%3E%3Cpath d='M0 0h1458v1458H0z'/%3E%3C/clipPath%3E%3Cg clip-path='url(%23a)'%3E%3Cpath d='M1458 729c0 402.655-326.345 729-729 729S0 1131.655 0 729C0 326.445 326.345 0 729 0s729 326.345 729 729' fill='%23e74c3c' fill-rule='nonzero'/%3E%3Cpath d='M778.349 1456.15L576.6 1254.401l233-105 85-78.668v-64.332l-257-257-44-187-50-208 251.806-82.793L1076.6 389.401l380.14 379.15c-19.681 367.728-311.914 663.049-678.391 687.599z' fill-opacity='.3'/%3E%3Cpath d='M753.4 329.503c41.79 0 74.579 7.83 97.925 25.444 23.571 18.015 41.69 43.956 55.167 77.097l11.662 28.679 165.733-58.183-14.137-32.13c-26.688-60.655-64.896-108.61-114.191-144.011-49.329-35.423-117.458-54.302-204.859-54.302-50.78 0-95.646 7.376-134.767 21.542-40.093 14.671-74.09 34.79-102.239 60.259-28.84 26.207-50.646 57.06-65.496 92.701-14.718 35.052-22.101 72.538-22.101 112.401 0 72.536 20.667 133.294 61.165 182.704 38.624 47.255 98.346 88.037 179.861 121.291 42.257 17.475 78.715 33.125 109.227 46.994 27.193 12.361 49.294 26.124 66.157 41.751 15.309 14.186 26.497 30.584 33.63 49.258 7.721 20.214 11.16 45.69 11.16 76.402 0 28.021-4.251 51.787-13.591 71.219-8.832 18.374-20.171 33.178-34.523 44.219-14.787 11.374-31.193 19.591-49.393 24.466-19.68 5.359-39.14 7.993-58.69 7.993-29.359 0-54.387-3.407-75.182-10.747-20.112-7.013-37.144-16.144-51.259-27.486-13.618-11.009-24.971-23.766-33.744-38.279-9.64-15.8-17.272-31.924-23.032-48.408l-10.965-31.376-161.669 60.585 10.734 30.124c10.191 28.601 24.197 56.228 42.059 82.748 18.208 27.144 41.322 51.369 69.525 72.745 27.695 21.075 60.904 38.218 99.481 51.041 37.777 12.664 82.004 19.159 132.552 19.159 49.998 0 95.818-8.321 137.611-24.622 42.228-16.471 78.436-38.992 108.835-67.291 30.719-28.597 54.631-62.103 71.834-100.642 17.263-38.56 25.923-79.392 25.923-122.248 0-54.339-8.368-100.37-24.208-138.32-16.29-38.759-38.252-71.661-65.948-98.797-26.965-26.418-58.269-48.835-93.858-67.175-33.655-17.241-69.196-33.11-106.593-47.533-35.934-13.429-65.822-26.601-89.948-39.525-22.153-11.868-40.009-24.21-53.547-37.309-11.429-11.13-19.83-23.678-24.718-37.664-5.413-15.49-7.98-33.423-7.98-53.577 0-40.883 11.293-71.522 37.086-90.539 28.443-20.825 64.985-30.658 109.311-30.658z' fill='%23f1c40f' fill-rule='nonzero'/%3E%3Cpath d='M720 0h18v113h-18zM1458 738v-18h-113v18h113zM720 1345h18v113h-18zM113 738v-18H0v18h113z'/%3E%3C/g%3E%3C/svg%3E"},"dependencies":{"@stryker-mutator/typescript-checker":"9.4.0","typescript":"5.9.3"}}}